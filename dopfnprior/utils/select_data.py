from typing import Dict, Optional, Tuple
from copy import deepcopy
import torch
import networkx as nx


def select_features(data: Dict[int, torch.Tensor],
                    dropout_prob: float,
                    generator: Optional[torch.Generator]
                    ) -> Tuple[torch.Tensor, torch.Tensor]:
    """
    Sample train and test tensors from data generated by an SCM. We write
        B for the batch dimension,
        N for the number of data points (rows) in each table,
        F for the number of features,
        D_i for the embedding dimension at node i.
            
    Modify `graph` in place by renaming its nodes and marking deleted nodes.
        
    Parameters:
    -----------
    data : dict
        The value at key i is a tensor of shape (B, N, D_i).
    dropout_prob : float
        The probability to drop any given feature.
            
    Returns
    -------
    X : tensor of shape (B, N, F)
        The features of the generated data batch.
    y : tensor of shape (B, N, 1)
        The targets of the generated data batch.
    """
    # select target node
    nodes = list(data.keys())
    target_node_idx = int(torch.randint(0, len(nodes), (1,), generator=generator))
    target_node = nodes[target_node_idx]
    target_values = data[target_node][:, :, 0]
        
    # treat non-target features
    nodes.remove(target_node)
    kept = []
    for i, v in enumerate(nodes):
        # make sure to keep at least two nodes, overriding the sampling if necessary
        if torch.rand(1, generator=generator) > dropout_prob or (len(kept) < 2 and i >= len(nodes) - 2):
            kept.append(v)
        
    feature_values = torch.cat(list(data[v] for v in kept), dim=2)
        
    # randomly switch signs
    B, N, F = feature_values.shape
    sign_x = torch.randint(0, 2, (B, 1, F), generator=generator, dtype=torch.float32) * 2 - 1
    feature_values *= sign_x
    sign_y = torch.randint(0, 2, (B, 1), generator=generator, dtype=torch.float32) * 2 - 1
    target_values *= sign_y
        
    # shuffle data
    perm_rows = torch.randperm(N, device=feature_values.device, generator=generator)
    X = feature_values[:, perm_rows, :]
    y = target_values[:, perm_rows]
        
    return X, y