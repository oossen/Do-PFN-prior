from typing import Dict, Optional, Tuple
import torch


def select_features(data: Dict[int, torch.Tensor],
                    dropout_prob: float,
                    generator: Optional[torch.Generator]
                    ) -> Tuple[torch.Tensor, torch.Tensor]:
    """
    Sample train and test tensors from data generated by an SCM. We write
        B for the batch dimension,
        N for the number of data points (rows) in each table,
        F for the number of features,
        D_i for the embedding dimension at node i.
            
    Modify `graph` in place by renaming its nodes and marking deleted nodes.
        
    Parameters:
    -----------
    data : dict
        The value at key i is a tensor of shape (B, N, D_i).
    dropout_prob : float
        The probability to drop any given feature.
            
    Returns
    -------
    X : tensor of shape (B, N, F)
        The features of the generated data batch.
    y : tensor of shape (B, N, 1)
        The targets of the generated data batch.
    """
    # Build data tensor [B, N, F_total]
    data_tensor = torch.cat(list(data.values()), dim=2)
    B, N, F = data_tensor.shape
    
    # randomly switch signs
    sign = torch.randint(0, 2, (B, 1, F), generator=generator, dtype=torch.float32) * 2 - 1
    data_tensor *= sign

    # Target selection
    target_feat = torch.randint(0, F, (1,), generator=generator)
    target_values = data_tensor[:, :, target_feat].squeeze(-1)

    # Candidate (non-target) columns
    remaining_cols = [i for i in range(F) if i != target_feat]
    kept = []
    dropped = []
    for col in remaining_cols:
        if torch.rand(1, generator=generator) < dropout_prob:
            dropped.append(col)
        else:
            kept.append(col)
    # Ensure at least one feature kept
    if len(kept) == 0:
        kept = [0]
        # remove it from dropped list if present
        dropped = dropped[1:]
        
    X = data_tensor[:, :, kept]
    y = target_values
        
    # shuffle data
    B, N, F = X.shape
    perm_rows = torch.randperm(N, device=X.device, generator=generator)
    X = X[:, perm_rows, :]
    y = y[:, perm_rows]
    perm_cols = torch.randperm(F, device=X.device, generator=generator)
    X = X[:, :, perm_cols]
        
    return X, y